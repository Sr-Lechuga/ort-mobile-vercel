## Resumen diario - 2025-10-01

### Cambios realizados

#### 1. Sistema de Caché (Cache System)

- Se implementó un **sistema de caché completo** con patrón adaptador en `Backend/src/4_services/cache/`.

  - Soporte para múltiples tipos de caché: **in-memory** (node-cache) y **Redis** (Upstash).
  - Arquitectura modular que permite agregar nuevos adaptadores fácilmente.
  - Configuración mediante variables de entorno (`CACHE_TYPE`, `CACHE_DEBUG`).

- Se crearon los siguientes archivos en `Backend/src/4_services/cache/`:

  - `cache.manager.js`: Gestor principal de caché con métodos `get`, `set`, `delete`.
  - `cache.service.js`: Servicio singleton que encapsula el CacheManager y proporciona métodos de alto nivel.
  - `index.js`: Punto de entrada del módulo de caché.
  - `adapters/index.js`: Factory para crear adaptadores de caché.
  - `adapters/inMemory.adapter.js`: Adaptador para caché en memoria usando node-cache.
  - `adapters/redis.adapter.js`: Adaptador para Redis usando @upstash/redis.

#### 2. Rate Limiting (Limitación de Tasa de Peticiones)

- Se implementó **protección contra ataques de fuerza bruta** y spam usando express-rate-limit.

- Se creó `Backend/src/config/rateLimiter.js`:

  - Configuración: límite de **30 peticiones por IP** cada **1 minuto**.
  - `windowMs: 1 * 60 * 1000` (ventana de tiempo de 1 minuto).
  - `max: 30` (máximo de peticiones permitidas por ventana).

- Se modificó `Backend/index.js`:
  - Se importó el módulo `rateLimiter` desde `./src/config/rateLimiter`.
  - Se aplicó como **primer middleware** de la aplicación (`app.use(rateLimiter)`).
  - Orden de middlewares: rateLimiter → cors() → express.json() → morgan().
  - Protección aplicada globalmente a todas las rutas.

#### 3. CORS (Cross-Origin Resource Sharing)

- Se agregó soporte para **peticiones cross-origin** usando el middleware cors.

- Se modificó `Backend/index.js`:
  - Se importó el módulo `cors`.
  - Se aplicó como segundo middleware después del rate limiter (`app.use(cors())`).
  - Configuración por defecto que permite peticiones desde cualquier origen.
  - Permite integración con aplicaciones frontend en diferentes dominios o puertos.

#### 4. Actualización de Constantes

- Se actualizó `Backend/src/utils/constants.js`:
  - Se agregó la constante `DEFAULT_TTL = 60 * 60 * 24` (24 horas) para TTL por defecto del caché.

### Características implementadas

#### CacheManager (`cache.manager.js`)

- **Constructor**: Acepta tipo de caché y modo debug (o lee de variables de entorno).
- **Métodos principales**:
  - `get(key)`: Obtiene un valor del caché y lo deserializa automáticamente desde JSON.
  - `set(key, value, ttl)`: Serializa y almacena un valor con TTL especificado.
  - `delete(key)`: Elimina una clave del caché.
- **Campos privados**: Usa `#type` y `#debug` para encapsulación.
- **Logging condicional**: Mensajes de debug detallados si `CACHE_DEBUG=true`.
- **Manejo de errores**: Parsing seguro de JSON con fallback al valor raw.

#### CacheService (`cache.service.js`)

- **Patrón Singleton**: Una única instancia del CacheManager durante el ciclo de vida de la aplicación.
- **Métodos disponibles**:
  - `get(key)`: Obtiene valores con manejo de errores y retorna `null` en caso de error.
  - `set(key, value, ttl = DEFAULT_TTL)`: Almacena valores con TTL por defecto de 24 horas.
  - `delete(key)`: Elimina una clave específica.
  - `deleteMultiple(keys)`: Elimina múltiples claves en paralelo usando `Promise.all`.
  - `generateKey(prefix, ...parts)`: Utilidad para generar claves de caché con formato `prefix:part1_part2_...`.
- **Getters**:
  - `getType()`: Retorna el tipo de caché configurado.
  - `isDebugEnabled()`: Indica si el modo debug está activo.

#### Adaptadores de caché

**In-Memory Adapter** (`inMemory.adapter.js`):

- Utiliza la librería `node-cache` para almacenamiento en memoria del proceso.
- Implementa patrón singleton para el cliente.
- Ideal para desarrollo y aplicaciones de baja escala.

**Redis Adapter** (`redis.adapter.js`):

- Utiliza `@upstash/redis` para conexión a Redis serverless.
- Requiere variables de entorno: `UPSTASH_REDIS_REST_URL` y `UPSTASH_REDIS_REST_TOKEN`.
- Implementa patrón singleton para el cliente.
- Lanza error descriptivo si faltan las credenciales.
- Usa el método `setex` específico de Redis para TTL.

#### Factory de adaptadores (`adapters/index.js`)

- `createCacheAdapter(type)`: Crea el adaptador apropiado según el tipo especificado.
- Acepta tipos: `"in-memory"`, `"memory"`, `"redis"`.
- Lanza error si se especifica un tipo no soportado.
- `getSupportedCacheAdapters()`: Retorna lista de adaptadores disponibles.

#### Rate Limiter (`rateLimiter.js`)

- **Configuración simplificada**: Utiliza `rateLimit` de express-rate-limit con configuración básica.
- **Parámetros**:
  - `windowMs: 1 * 60 * 1000`: Ventana de tiempo de 1 minuto (60,000 ms).
  - `max: 30`: Máximo de 30 peticiones por ventana por IP.
- **Exportación directa**: Se exporta el middleware configurado listo para usar.
- **Comportamiento**: Cuando se excede el límite, responde automáticamente con status 429 (Too Many Requests).

### Decisiones técnicas

#### Sistema de Caché

1. **Patrón Adaptador**: Permite cambiar fácilmente entre diferentes implementaciones de caché sin modificar el código que lo consume.

2. **Serialización automática**: Todos los valores se serializan a JSON antes de almacenar y se deserializan al recuperar, permitiendo almacenar objetos complejos.

3. **Variables de entorno**:

   - `CACHE_TYPE`: Define el tipo de caché (`in-memory` por defecto).
   - `CACHE_DEBUG`: Habilita logging detallado para debugging.
   - `UPSTASH_REDIS_REST_URL` y `UPSTASH_REDIS_REST_TOKEN`: Credenciales para Redis.

4. **TTL por defecto**: Se estableció en 24 horas para equilibrar entre freshness de datos y reducción de carga en la base de datos.

5. **Manejo de errores graceful**: El CacheService captura errores y retorna valores seguros (`null` o `false`) para evitar que problemas de caché afecten la aplicación.

6. **Logging condicional**: El sistema de debug permite troubleshooting sin afectar el rendimiento en producción.

#### Rate Limiting

1. **Límite conservador**: 30 peticiones por minuto permite uso normal de la API mientras protege contra ataques automatizados.

2. **Aplicación global**: El middleware se aplica en todas las rutas para protección uniforme del servidor.

3. **Rate limiting por IP**: Cada dirección IP tiene su propio límite independiente, evitando que un usuario afecte a otros.

4. **Ubicación del middleware**: Se coloca como primer middleware para rechazar peticiones excesivas antes de procesarlas, ahorrando recursos.

#### CORS

1. **Configuración permisiva por defecto**: Se usa la configuración por defecto de cors que permite cualquier origen, ideal para desarrollo.

2. **Orden de middlewares**: CORS se aplica después del rate limiter pero antes del parsing de JSON para manejar las preflight requests correctamente.

3. **Preparación para producción**: En producción se puede configurar para permitir solo orígenes específicos por seguridad.

### Archivos creados

**Sistema de Caché:**

- `Backend/src/4_services/cache/cache.manager.js`
- `Backend/src/4_services/cache/cache.service.js`
- `Backend/src/4_services/cache/index.js`
- `Backend/src/4_services/cache/adapters/index.js`
- `Backend/src/4_services/cache/adapters/inMemory.adapter.js`
- `Backend/src/4_services/cache/adapters/redis.adapter.js`

**Rate Limiting:**

- `Backend/src/config/rateLimiter.js`

### Archivos modificados

- `Backend/index.js` (integrado middleware de rate limiting y CORS)
- `Backend/src/utils/constants.js` (agregada constante `DEFAULT_TTL`)
- `documentacion/dependencies.md` (agregadas dependencias node-cache, @upstash/redis, express-rate-limit y cors)

### Pendientes

- [x] ~~Actualizar `documentacion/dependencies.md` con las nuevas dependencias~~ ✅ Completado
  - `node-cache` (^5.1.2): Librería de caché en memoria
  - `@upstash/redis` (^1.35.4): Cliente de Redis serverless
  - `express-rate-limit` (^8.1.0): Middleware de rate limiting para Express
  - `cors` (^2.8.5): Middleware para habilitar CORS
- [ ] Integrar el CacheService en los servicios existentes (activity.service.js, organizer.service.js, volunteer.service.js, etc.)
- [ ] Crear archivo `.env.example` con las variables de entorno necesarias
- [ ] Considerar agregar tests unitarios para el sistema de caché

### Próximos pasos sugeridos

**Sistema de Caché:**

1. Integrar el caché en las consultas más frecuentes (listados de actividades, búsquedas, etc.)
2. Implementar invalidación de caché en operaciones de escritura (create, update, delete)
3. Definir estrategias de caching según el tipo de dato:
   - Listados: cache con TTL corto
   - Detalles de entidades: cache con TTL largo e invalidación explícita
   - Búsquedas: cache con parámetros en la clave
4. Documentar patrones de uso del caché en el proyecto
5. Configurar Redis en el ambiente de producción/staging

**Rate Limiting:**

1. Considerar límites diferentes por tipo de endpoint (más restrictivo en auth, más permisivo en lectura)
2. Implementar mensajes de error personalizados cuando se exceda el límite
3. Evaluar el uso de Redis como store para rate limiting en producción (permite compartir límites entre múltiples instancias del servidor)
4. Monitorear y ajustar los límites según patrones de uso reales

**CORS:**

1. En producción, configurar orígenes permitidos específicos en lugar de permitir todos
2. Considerar configurar métodos HTTP permitidos explícitamente
3. Evaluar la necesidad de credentials (cookies, headers de autenticación) en peticiones cross-origin
4. Documentar los orígenes permitidos en las variables de entorno

### Notas

- Todas las implementaciones siguen las reglas del repositorio: comentarios en español, camelCase para variables y funciones, PascalCase para clases.
- El sistema de caché está listo para usar pero requiere instalación de dependencias (`node-cache` y `@upstash/redis`).
- Se recomienda usar `in-memory` para desarrollo local y `redis` para producción.
- El rate limiting está activo y protege todas las rutas de la aplicación automáticamente.
- La configuración actual permite 30 peticiones por minuto por IP, ajustable según necesidades del proyecto.
- CORS está habilitado con configuración permisiva (todos los orígenes) para facilitar el desarrollo.
- En producción se debe configurar CORS para permitir solo los orígenes específicos del frontend.
